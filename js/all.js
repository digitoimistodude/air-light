!function(n){var e={};function t(o){if(e[o])return e[o].exports;var i=e[o]={i:o,l:!1,exports:{}};return n[o].call(i.exports,i,i.exports,t),i.l=!0,i.exports}t.m=n,t.c=e,t.d=function(n,e,o){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:o})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var o=Object.create(null);if(t.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var i in n)t.d(o,i,function(e){return n[e]}.bind(null,i));return o},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="",t(t.s="./js/src/scripts.js")}({"./js/src/air-nav.js":
/*!***************************!*\
  !*** ./js/src/air-nav.js ***!
  \***************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return AirNav; });\nclass AirNav {\n  constructor(target) {\n    const args = {\n      toggled: false,\n      // Initial state\n      classes: {\n        toggledOn: 'toggled-on',\n        toggledOff: 'toggled-off',\n        animate: 'animate'\n      },\n      delay: 1000,\n      // Animation delay in milliseconds, false/0 to disable animations\n      toggleElements: [// Additional selectors to set toggles on\n      'body', '.main-navigation-wrapper']\n    };\n    debugger;\n    this.navigation = target;\n    this.args = args;\n    this.state = this.args.toggled ? 'toggledOff' : 'toggledOn'; // Find additional toggle elements and set initial\n\n    this.toggleElements = document.querySelectorAll(this.args.toggleElements);\n    this.toggleElements.forEach(element => element.classList.add(this.navigation.id + '-' + this.args.classes[this.state])); // If toggles are not defined in the instance, try to find them in DOM\n\n    if (!args.hasOwnProperty('toggles')) {\n      args.toggles = document.querySelectorAll('[data-air-nav-toggle=' + target.id + ']');\n    }\n\n    args.toggles.forEach(toggle => this.initToggle(toggle));\n    this.initNavigation();\n  } // Set initial values to nav container\n\n\n  initNavigation() {\n    this.navigation.setAttribute('aria-expanded', this.args.toggled);\n    this.navigation.classList.add(this.args.toggled ? this.args.classes.toggledOn : this.args.classes.toggledOff);\n  }\n  /**\n   * Initialize a menu toggle\n   */\n\n\n  initToggle(menuToggle) {\n    menuToggle.setAttribute('aria-expanded', this.args.toggled);\n    menuToggle.classList.add(this.args.classes[this.state]);\n    menuToggle.addEventListener('click', e => {\n      // Let animation finish\n      if (this.animating) {\n        return;\n      }\n\n      this.toggleClick();\n    });\n  }\n  /**\n   * Event listener callback for an toggle click\n   */\n\n\n  toggleClick() {\n    // Find out what was the current state about to change\n    this.lastState = this.args.toggled ? 'toggledOn' : 'toggledOff';\n\n    if (this.args.delay) {\n      this.addClass(this.args.classes.animate);\n      this.animating = true;\n      window.setTimeout(e => {\n        this.toggleEvent();\n        this.animating = false;\n        this.removeClass(this.args.classes.animate);\n      }, this.args.delay);\n    } else {\n      this.toggleEvent();\n    }\n  }\n  /**\n   * Toggle event callback\n   */\n\n\n  toggleEvent() {\n    // Toggle the state\n    this.args.toggled = !this.args.toggled;\n    this.state = this.args.toggled ? 'toggledOn' : 'toggledOff';\n    this.setAttributes();\n    this.addClass(this.args.classes[this.state]);\n    this.removeClass(this.args.classes[this.lastState]);\n  }\n\n  addClass(className) {\n    this.navigation.classList.add(className);\n    this.args.toggles.forEach(toggle => {\n      toggle.classList.add(className);\n    });\n    this.toggleElements.forEach(element => {\n      element.classList.add(this.navigation.id + '-' + className);\n    });\n  }\n\n  removeClass(className) {\n    this.navigation.classList.remove(className);\n    this.args.toggles.forEach(toggle => {\n      toggle.classList.remove(className);\n    });\n    this.toggleElements.forEach(element => {\n      element.classList.remove(this.navigation.id + '-' + className);\n    });\n  }\n\n  setAttributes() {\n    this.navigation.setAttribute('aria-expanded', this.args.toggled); // Set toggles attrs\n\n    this.args.toggles.forEach(toggle => {\n      toggle.setAttribute('aria-expanded', this.args.toggled);\n    });\n  }\n\n}\n\n//# sourceURL=webpack:///./js/src/air-nav.js?")},"./js/src/lazyload.js":
/*!****************************!*\
  !*** ./js/src/lazyload.js ***!
  \****************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {/*!\n * Lazy Load - JavaScript plugin for lazy loading images\n *\n * Copyright (c) 2007-2019 Mika Tuupola\n *\n * Licensed under the MIT license:\n *   http://www.opensource.org/licenses/mit-license.php\n *\n * Project home:\n *   https://appelsiini.net/projects/lazyload\n *\n * Version: 2.0.0-rc.2\n * Modified by rolle\n *\n */\n(function (root, factory) {\n  if (true) {\n    module.exports = factory(root);\n  } else {}\n})(typeof global !== "undefined" ? global : this.window || this.global, function (root) {\n  "use strict";\n\n  if (true) {\n    root = window;\n  }\n\n  const defaults = {\n    src: "data-src",\n    srcmobile: "data-src-mobile",\n    srcset: "data-srcset",\n    selector: ".lazyload",\n    root: null,\n    rootMargin: "0px",\n    threshold: 0\n  };\n  /**\n  * Merge two or more objects. Returns a new object.\n  * @private\n  * @param {Boolean}  deep     If true, do a deep (or recursive) merge [optional]\n  * @param {Object}   objects  The objects to merge together\n  * @returns {Object}          Merged values of defaults and options\n  */\n\n  const extend = function () {\n    let extended = {};\n    let deep = false;\n    let i = 0;\n    let length = arguments.length;\n    /* Check if a deep merge */\n\n    if (Object.prototype.toString.call(arguments[0]) === "[object Boolean]") {\n      deep = arguments[0];\n      i++;\n    }\n    /* Merge the object into the extended object */\n\n\n    let merge = function (obj) {\n      for (let prop in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n          /* If deep merge and property is an object, merge properties */\n          if (deep && Object.prototype.toString.call(obj[prop]) === "[object Object]") {\n            extended[prop] = extend(true, extended[prop], obj[prop]);\n          } else {\n            extended[prop] = obj[prop];\n          }\n        }\n      }\n    };\n    /* Loop through each object and conduct a merge */\n\n\n    for (; i < length; i++) {\n      let obj = arguments[i];\n      merge(obj);\n    }\n\n    return extended;\n  };\n\n  function LazyLoad(images, options) {\n    this.settings = extend(defaults, options || {});\n    this.images = images || document.querySelectorAll(this.settings.selector);\n    this.observer = null;\n    this.init();\n  }\n\n  LazyLoad.prototype = {\n    init: function () {\n      /* Without observers load everything and bail out early.\n         This affects some iOS and Windows Phones */\n      if (!root.IntersectionObserver) {\n        this.loadImages();\n        return;\n      }\n\n      let self = this;\n      let observerConfig = {\n        root: this.settings.root,\n        rootMargin: this.settings.rootMargin,\n        threshold: [this.settings.threshold]\n      };\n      this.observer = new IntersectionObserver(function (entries) {\n        Array.prototype.forEach.call(entries, function (entry) {\n          /* If inside viewport */\n          if (entry.isIntersecting) {\n            /* Define image */\n            const img = entry.target;\n            /* Add animation class to full-image div */\n\n            if (typeof img.nextElementSibling != \'undefined\' && img.nextElementSibling != null) {\n              img.nextElementSibling.classList.add(\'reveal\');\n            }\n\n            self.observer.unobserve(entry.target);\n            let src = img.getAttribute(self.settings.src);\n            let srcset = img.getAttribute(self.settings.srcset);\n            let srcmobile = img.getAttribute(self.settings.srcmobile);\n            /* Replace fully loaded original background image to the img src */\n\n            if (\'img\' === img.tagName.toLowerCase()) {\n              if (document.documentElement.clientWidth < 600) {\n                img.src = srcmobile;\n              } else {\n                img.src = src;\n              }\n            } else {\n              /* Add fully loaded original background image to next div element */\n              if (document.documentElement.clientWidth < 600) {\n                img.nextElementSibling.style.backgroundImage = "url(" + srcmobile + ")";\n              } else {\n                img.nextElementSibling.style.backgroundImage = "url(" + src + ")";\n              }\n            }\n          }\n        });\n      }, observerConfig);\n      Array.prototype.forEach.call(this.images, function (image) {\n        self.observer.observe(image);\n      });\n    },\n    loadAndDestroy: function () {\n      if (!this.settings) {\n        return;\n      }\n\n      this.loadImages();\n      this.destroy();\n    },\n    loadImages: function () {\n      if (!this.settings) {\n        return;\n      }\n\n      let self = this;\n      Array.prototype.forEach.call(this.images, function (image) {\n        let src = image.getAttribute(self.settings.src);\n        let srcset = image.getAttribute(self.settings.srcset);\n        let srcmobile = image.getAttribute(self.settings.srcmobile);\n\n        if ("img" === image.tagName.toLowerCase()) {\n          if (src) {\n            image.src = src;\n          }\n\n          if (srcset) {\n            image.srcset = srcset;\n          }\n\n          if (srcmobile) {\n            image.srcmobile = srcmobile;\n          }\n        } else {\n          if (document.documentElement.clientWidth < 600) {\n            image.style.backgroundImage = "url(\'" + srcmobile + "\')";\n          } else {\n            image.style.backgroundImage = "url(\'" + src + "\')";\n          }\n        }\n      });\n    },\n    destroy: function () {\n      if (!this.settings) {\n        return;\n      }\n\n      this.observer.disconnect();\n      this.settings = null;\n    }\n  };\n\n  root.lazyload = function (images, options) {\n    return new LazyLoad(images, options);\n  };\n\n  if (root.jQuery) {\n    const $ = root.jQuery;\n\n    $.fn.lazyload = function (options) {\n      options = options || {};\n      options.attribute = options.attribute || "data-src";\n      new LazyLoad($.makeArray(this), options);\n      return this;\n    };\n  }\n\n  return LazyLoad;\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))\n\n//# sourceURL=webpack:///./js/src/lazyload.js?')},"./js/src/scripts.js":
/*!***************************!*\
  !*** ./js/src/scripts.js ***!
  \***************************/
/*! no exports provided */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var moveto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! moveto */ "./node_modules/moveto/dist/moveTo.js");\n/* harmony import */ var moveto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(moveto__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var what_input__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! what-input */ "./node_modules/what-input/dist/what-input.js");\n/* harmony import */ var what_input__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(what_input__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _air_nav_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./air-nav.js */ "./js/src/air-nav.js");\n/* harmony import */ var _lazyload_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lazyload.js */ "./js/src/lazyload.js");\n/* harmony import */ var _lazyload_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_lazyload_js__WEBPACK_IMPORTED_MODULE_3__);\n/**\n * Air theme JavaScript.\n */\n// Import modules (comment to disable)\n // import \'./sticky-nav.js\'\n// import slick from \'slick-carousel\';\n\n // import "./navigation.js";\n\n\n // Define Javascript is active by changing the body class\n\ndocument.body.classList.remove("no-js");\ndocument.body.classList.add("js"); // Init lazyload\n// Usage example on template side when air-helper enabled:\n// <?php image_lazyload_tag( get_post_thumbnail_id( $post->ID ) ); ?>\n\nlet images = document.querySelectorAll(".lazyload");\nlazyload(images, {\n  root: null,\n  rootMargin: "0px",\n  threshold: 0\n});\nconst nav = new _air_nav_js__WEBPACK_IMPORTED_MODULE_2__["default"](document.querySelector(\'.nav-primary\')); // jQuery start\n\n(function ($) {\n  // Accessibility: Ensure back to top is right color on right background\n  // Note: Needs .has-light-bg or .has-dark-bg class on all blocks\n  var stickyOffset = $(".back-to-top").offset();\n  var $contentDivs = $(".block");\n  $(document).scroll(function () {\n    $contentDivs.each(function (k) {\n      var _thisOffset = $(this).offset();\n\n      var _actPosition = _thisOffset.top - $(window).scrollTop();\n\n      if (_actPosition < stickyOffset.top && _actPosition + $(this).height() > 0) {\n        $(".back-to-top").removeClass("has-light-bg has-dark-bg").addClass($(this).hasClass("has-light-bg") ? "has-light-bg" : "has-dark-bg");\n        return false;\n      }\n    });\n  }); // Hide or show the "back to top" link\n\n  $(window).scroll(function () {\n    // Back to top\n    var offset = 300; // Browser window scroll (in pixels) after which the "back to top" link is shown\n\n    var offset_opacity = 1200; // Browser window scroll (in pixels) after which the link opacity is reduced\n\n    var scroll_top_duration = 700; // Duration of the top scrolling animation (in ms)\n\n    var link_class = ".back-to-top";\n\n    if ($(this).scrollTop() > offset) {\n      $(link_class).addClass("is-visible");\n    } else {\n      $(link_class).removeClass("is-visible");\n    }\n\n    if ($(this).scrollTop() > offset_opacity) {\n      $(link_class).addClass("fade-out");\n    } else {\n      $(link_class).removeClass("fade-out");\n    }\n  }); // Document ready start\n\n  $(function () {// Your jQuery here\n  });\n})(jQuery);\n\ndocument.addEventListener("DOMContentLoaded", function () {\n  const easeFunctions = {\n    easeInQuad: function (t, b, c, d) {\n      t /= d;\n      return c * t * t + b;\n    },\n    easeOutQuad: function (t, b, c, d) {\n      t /= d;\n      return -c * t * (t - 2) + b;\n    }\n  };\n  const moveTo = new moveto__WEBPACK_IMPORTED_MODULE_0___default.a({\n    ease: "easeInQuad"\n  }, easeFunctions);\n  const triggers = document.getElementsByClassName("js-trigger");\n\n  for (var i = 0; i < triggers.length; i++) {\n    moveTo.registerTrigger(triggers[i]);\n  }\n});\n\n//# sourceURL=webpack:///./js/src/scripts.js?')},"./node_modules/moveto/dist/moveTo.js":
/*!********************************************!*\
  !*** ./node_modules/moveto/dist/moveTo.js ***!
  \********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("/*!\n * MoveTo - A lightweight scroll animation javascript library without any dependency.\n * Version 1.8.2 (28-06-2019 14:30)\n * Licensed under MIT\n * Copyright 2019 Hasan AydoÄŸdu <hsnaydd@gmail.com>\n */\n\n\nvar MoveTo = function () {\n  /**\n   * Defaults\n   * @type {object}\n   */\n  var defaults = {\n    tolerance: 0,\n    duration: 800,\n    easing: 'easeOutQuart',\n    container: window,\n    callback: function callback() {}\n  };\n  /**\n   * easeOutQuart Easing Function\n   * @param  {number} t - current time\n   * @param  {number} b - start value\n   * @param  {number} c - change in value\n   * @param  {number} d - duration\n   * @return {number} - calculated value\n   */\n\n  function easeOutQuart(t, b, c, d) {\n    t /= d;\n    t--;\n    return -c * (t * t * t * t - 1) + b;\n  }\n  /**\n   * Merge two object\n   *\n   * @param  {object} obj1\n   * @param  {object} obj2\n   * @return {object} merged object\n   */\n\n\n  function mergeObject(obj1, obj2) {\n    var obj3 = {};\n    Object.keys(obj1).forEach(function (propertyName) {\n      obj3[propertyName] = obj1[propertyName];\n    });\n    Object.keys(obj2).forEach(function (propertyName) {\n      obj3[propertyName] = obj2[propertyName];\n    });\n    return obj3;\n  }\n\n  ;\n  /**\n   * Converts camel case to kebab case\n   * @param  {string} val the value to be converted\n   * @return {string} the converted value\n   */\n\n  function kebabCase(val) {\n    return val.replace(/([A-Z])/g, function ($1) {\n      return '-' + $1.toLowerCase();\n    });\n  }\n\n  ;\n  /**\n   * Count a number of item scrolled top\n   * @param  {Window|HTMLElement} container\n   * @return {number}\n   */\n\n  function countScrollTop(container) {\n    if (container instanceof HTMLElement) {\n      return container.scrollTop;\n    }\n\n    return container.pageYOffset;\n  }\n\n  ;\n  /**\n   * MoveTo Constructor\n   * @param {object} options Options\n   * @param {object} easeFunctions Custom ease functions\n   */\n\n  function MoveTo() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var easeFunctions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.options = mergeObject(defaults, options);\n    this.easeFunctions = mergeObject({\n      easeOutQuart: easeOutQuart\n    }, easeFunctions);\n  }\n  /**\n   * Register a dom element as trigger\n   * @param  {HTMLElement} dom Dom trigger element\n   * @param  {function} callback Callback function\n   * @return {function|void} unregister function\n   */\n\n\n  MoveTo.prototype.registerTrigger = function (dom, callback) {\n    var _this = this;\n\n    if (!dom) {\n      return;\n    }\n\n    var href = dom.getAttribute('href') || dom.getAttribute('data-target'); // The element to be scrolled\n\n    var target = href && href !== '#' ? document.getElementById(href.substring(1)) : document.body;\n    var options = mergeObject(this.options, _getOptionsFromTriggerDom(dom, this.options));\n\n    if (typeof callback === 'function') {\n      options.callback = callback;\n    }\n\n    var listener = function listener(e) {\n      e.preventDefault();\n\n      _this.move(target, options);\n    };\n\n    dom.addEventListener('click', listener, false);\n    return function () {\n      return dom.removeEventListener('click', listener, false);\n    };\n  };\n  /**\n   * Move\n   * Scrolls to given element by using easeOutQuart function\n   * @param  {HTMLElement|number} target Target element to be scrolled or target position\n   * @param  {object} options Custom options\n   */\n\n\n  MoveTo.prototype.move = function (target) {\n    var _this2 = this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (target !== 0 && !target) {\n      return;\n    }\n\n    options = mergeObject(this.options, options);\n    var distance = typeof target === 'number' ? target : target.getBoundingClientRect().top;\n    var from = countScrollTop(options.container);\n    var startTime = null;\n    var lastYOffset;\n    distance -= options.tolerance; // rAF loop\n\n    var loop = function loop(currentTime) {\n      var currentYOffset = countScrollTop(_this2.options.container);\n\n      if (!startTime) {\n        // To starts time from 1, we subtracted 1 from current time\n        // If time starts from 1 The first loop will not do anything,\n        // because easing value will be zero\n        startTime = currentTime - 1;\n      }\n\n      var timeElapsed = currentTime - startTime;\n\n      if (lastYOffset) {\n        if (distance > 0 && lastYOffset > currentYOffset || distance < 0 && lastYOffset < currentYOffset) {\n          return options.callback(target);\n        }\n      }\n\n      lastYOffset = currentYOffset;\n\n      var val = _this2.easeFunctions[options.easing](timeElapsed, from, distance, options.duration);\n\n      options.container.scroll(0, val);\n\n      if (timeElapsed < options.duration) {\n        window.requestAnimationFrame(loop);\n      } else {\n        options.container.scroll(0, distance + from);\n        options.callback(target);\n      }\n    };\n\n    window.requestAnimationFrame(loop);\n  };\n  /**\n   * Adds custom ease function\n   * @param {string}   name Ease function name\n   * @param {function} fn   Ease function\n   */\n\n\n  MoveTo.prototype.addEaseFunction = function (name, fn) {\n    this.easeFunctions[name] = fn;\n  };\n  /**\n   * Returns options which created from trigger dom element\n   * @param  {HTMLElement} dom Trigger dom element\n   * @param  {object} options The instance's options\n   * @return {object} The options which created from trigger dom element\n   */\n\n\n  function _getOptionsFromTriggerDom(dom, options) {\n    var domOptions = {};\n    Object.keys(options).forEach(function (key) {\n      var value = dom.getAttribute(\"data-mt-\".concat(kebabCase(key)));\n\n      if (value) {\n        domOptions[key] = isNaN(value) ? value : parseInt(value, 10);\n      }\n    });\n    return domOptions;\n  }\n\n  return MoveTo;\n}();\n\nif (true) {\n  module.exports = MoveTo;\n} else {}\n\n//# sourceURL=webpack:///./node_modules/moveto/dist/moveTo.js?")},"./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */function(module,exports){eval('var g; // This works in non-strict mode\n\ng = function () {\n  return this;\n}();\n\ntry {\n  // This works if eval is allowed (see CSP)\n  g = g || new Function("return this")();\n} catch (e) {\n  // This works if the window reference is available\n  if (typeof window === "object") g = window;\n} // g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\n\nmodule.exports = g;\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?')},"./node_modules/what-input/dist/what-input.js":
/*!****************************************************!*\
  !*** ./node_modules/what-input/dist/what-input.js ***!
  \****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("/**\n * what-input - A global utility for tracking the current input method (mouse, keyboard or touch).\n * @version v5.2.10\n * @link https://github.com/ten1seven/what-input\n * @license MIT\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (true) module.exports = factory();else {}\n})(this, function () {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId])\n          /******/\n          return installedModules[moduleId].exports;\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n        var module = installedModules[moduleId] = {\n          /******/\n          exports: {},\n\n          /******/\n          id: moduleId,\n\n          /******/\n          loaded: false\n          /******/\n\n        };\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.loaded = true;\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n      __webpack_require__.p = \"\";\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(0);\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    [\n    /* 0 */\n\n    /***/\n    function (module, exports) {\n      'use strict';\n\n      module.exports = function () {\n        /*\n         * bail out if there is no document or window\n         * (i.e. in a node/non-DOM environment)\n         *\n         * Return a stubbed API instead\n         */\n        if (typeof document === 'undefined' || typeof window === 'undefined') {\n          return {\n            // always return \"initial\" because no interaction will ever be detected\n            ask: function ask() {\n              return 'initial';\n            },\n            // always return null\n            element: function element() {\n              return null;\n            },\n            // no-op\n            ignoreKeys: function ignoreKeys() {},\n            // no-op\n            specificKeys: function specificKeys() {},\n            // no-op\n            registerOnChange: function registerOnChange() {},\n            // no-op\n            unRegisterOnChange: function unRegisterOnChange() {}\n          };\n        }\n        /*\n         * variables\n         */\n        // cache document.documentElement\n\n\n        var docElem = document.documentElement; // currently focused dom element\n\n        var currentElement = null; // last used input type\n\n        var currentInput = 'initial'; // last used input intent\n\n        var currentIntent = currentInput; // UNIX timestamp of current event\n\n        var currentTimestamp = Date.now(); // check for a `data-whatpersist` attribute on either the `html` or `body` elements, defaults to `true`\n\n        var shouldPersist = 'false'; // form input types\n\n        var formInputs = ['button', 'input', 'select', 'textarea']; // empty array for holding callback functions\n\n        var functionList = []; // list of modifier keys commonly used with the mouse and\n        // can be safely ignored to prevent false keyboard detection\n\n        var ignoreMap = [16, // shift\n        17, // control\n        18, // alt\n        91, // Windows key / left Apple cmd\n        93 // Windows menu / right Apple cmd\n        ];\n        var specificMap = []; // mapping of events to input types\n\n        var inputMap = {\n          keydown: 'keyboard',\n          keyup: 'keyboard',\n          mousedown: 'mouse',\n          mousemove: 'mouse',\n          MSPointerDown: 'pointer',\n          MSPointerMove: 'pointer',\n          pointerdown: 'pointer',\n          pointermove: 'pointer',\n          touchstart: 'touch',\n          touchend: 'touch' // boolean: true if the page is being scrolled\n\n        };\n        var isScrolling = false; // store current mouse position\n\n        var mousePos = {\n          x: null,\n          y: null // map of IE 10 pointer events\n\n        };\n        var pointerMap = {\n          2: 'touch',\n          3: 'touch',\n          // treat pen like touch\n          4: 'mouse' // check support for passive event listeners\n\n        };\n        var supportsPassive = false;\n\n        try {\n          var opts = Object.defineProperty({}, 'passive', {\n            get: function get() {\n              supportsPassive = true;\n            }\n          });\n          window.addEventListener('test', null, opts);\n        } catch (e) {} // fail silently\n\n        /*\n         * set up\n         */\n\n\n        var setUp = function setUp() {\n          // add correct mouse wheel event mapping to `inputMap`\n          inputMap[detectWheel()] = 'mouse';\n          addListeners();\n        };\n        /*\n         * events\n         */\n\n\n        var addListeners = function addListeners() {\n          // `pointermove`, `MSPointerMove`, `mousemove` and mouse wheel event binding\n          // can only demonstrate potential, but not actual, interaction\n          // and are treated separately\n          var options = supportsPassive ? {\n            passive: true\n          } : false;\n          document.addEventListener('DOMContentLoaded', setPersist); // pointer events (mouse, pen, touch)\n\n          if (window.PointerEvent) {\n            window.addEventListener('pointerdown', setInput);\n            window.addEventListener('pointermove', setIntent);\n          } else if (window.MSPointerEvent) {\n            window.addEventListener('MSPointerDown', setInput);\n            window.addEventListener('MSPointerMove', setIntent);\n          } else {\n            // mouse events\n            window.addEventListener('mousedown', setInput);\n            window.addEventListener('mousemove', setIntent); // touch events\n\n            if ('ontouchstart' in window) {\n              window.addEventListener('touchstart', setInput, options);\n              window.addEventListener('touchend', setInput);\n            }\n          } // mouse wheel\n\n\n          window.addEventListener(detectWheel(), setIntent, options); // keyboard events\n\n          window.addEventListener('keydown', setInput);\n          window.addEventListener('keyup', setInput); // focus events\n\n          window.addEventListener('focusin', setElement);\n          window.addEventListener('focusout', clearElement);\n        }; // checks if input persistence should happen and\n        // get saved state from session storage if true (defaults to `false`)\n\n\n        var setPersist = function setPersist() {\n          shouldPersist = !(docElem.getAttribute('data-whatpersist') || document.body.getAttribute('data-whatpersist') === 'false');\n\n          if (shouldPersist) {\n            // check for session variables and use if available\n            try {\n              if (window.sessionStorage.getItem('what-input')) {\n                currentInput = window.sessionStorage.getItem('what-input');\n              }\n\n              if (window.sessionStorage.getItem('what-intent')) {\n                currentIntent = window.sessionStorage.getItem('what-intent');\n              }\n            } catch (e) {// fail silently\n            }\n          } // always run these so at least `initial` state is set\n\n\n          doUpdate('input');\n          doUpdate('intent');\n        }; // checks conditions before updating new input\n\n\n        var setInput = function setInput(event) {\n          var eventKey = event.which;\n          var value = inputMap[event.type];\n\n          if (value === 'pointer') {\n            value = pointerType(event);\n          }\n\n          var ignoreMatch = !specificMap.length && ignoreMap.indexOf(eventKey) === -1;\n          var specificMatch = specificMap.length && specificMap.indexOf(eventKey) !== -1;\n          var shouldUpdate = value === 'keyboard' && eventKey && (ignoreMatch || specificMatch) || value === 'mouse' || value === 'touch'; // prevent touch detection from being overridden by event execution order\n\n          if (validateTouch(value)) {\n            shouldUpdate = false;\n          }\n\n          if (shouldUpdate && currentInput !== value) {\n            currentInput = value;\n            persistInput('input', currentInput);\n            doUpdate('input');\n          }\n\n          if (shouldUpdate && currentIntent !== value) {\n            // preserve intent for keyboard interaction with form fields\n            var activeElem = document.activeElement;\n            var notFormInput = activeElem && activeElem.nodeName && (formInputs.indexOf(activeElem.nodeName.toLowerCase()) === -1 || activeElem.nodeName.toLowerCase() === 'button' && !checkClosest(activeElem, 'form'));\n\n            if (notFormInput) {\n              currentIntent = value;\n              persistInput('intent', currentIntent);\n              doUpdate('intent');\n            }\n          }\n        }; // updates the doc and `inputTypes` array with new input\n\n\n        var doUpdate = function doUpdate(which) {\n          docElem.setAttribute('data-what' + which, which === 'input' ? currentInput : currentIntent);\n          fireFunctions(which);\n        }; // updates input intent for `mousemove` and `pointermove`\n\n\n        var setIntent = function setIntent(event) {\n          var value = inputMap[event.type];\n\n          if (value === 'pointer') {\n            value = pointerType(event);\n          } // test to see if `mousemove` happened relative to the screen to detect scrolling versus mousemove\n\n\n          detectScrolling(event); // only execute if scrolling isn't happening\n\n          if ((!isScrolling && !validateTouch(value) || isScrolling && event.type === 'wheel' || event.type === 'mousewheel' || event.type === 'DOMMouseScroll') && currentIntent !== value) {\n            currentIntent = value;\n            persistInput('intent', currentIntent);\n            doUpdate('intent');\n          }\n        };\n\n        var setElement = function setElement(event) {\n          if (!event.target.nodeName) {\n            // If nodeName is undefined, clear the element\n            // This can happen if click inside an <svg> element.\n            clearElement();\n            return;\n          }\n\n          currentElement = event.target.nodeName.toLowerCase();\n          docElem.setAttribute('data-whatelement', currentElement);\n\n          if (event.target.classList && event.target.classList.length) {\n            docElem.setAttribute('data-whatclasses', event.target.classList.toString().replace(' ', ','));\n          }\n        };\n\n        var clearElement = function clearElement() {\n          currentElement = null;\n          docElem.removeAttribute('data-whatelement');\n          docElem.removeAttribute('data-whatclasses');\n        };\n\n        var persistInput = function persistInput(which, value) {\n          if (shouldPersist) {\n            try {\n              window.sessionStorage.setItem('what-' + which, value);\n            } catch (e) {// fail silently\n            }\n          }\n        };\n        /*\n         * utilities\n         */\n\n\n        var pointerType = function pointerType(event) {\n          if (typeof event.pointerType === 'number') {\n            return pointerMap[event.pointerType];\n          } else {\n            // treat pen like touch\n            return event.pointerType === 'pen' ? 'touch' : event.pointerType;\n          }\n        }; // prevent touch detection from being overridden by event execution order\n\n\n        var validateTouch = function validateTouch(value) {\n          var timestamp = Date.now();\n          var touchIsValid = value === 'mouse' && currentInput === 'touch' && timestamp - currentTimestamp < 200;\n          currentTimestamp = timestamp;\n          return touchIsValid;\n        }; // detect version of mouse wheel event to use\n        // via https://developer.mozilla.org/en-US/docs/Web/API/Element/wheel_event\n\n\n        var detectWheel = function detectWheel() {\n          var wheelType = null; // Modern browsers support \"wheel\"\n\n          if ('onwheel' in document.createElement('div')) {\n            wheelType = 'wheel';\n          } else {\n            // Webkit and IE support at least \"mousewheel\"\n            // or assume that remaining browsers are older Firefox\n            wheelType = document.onmousewheel !== undefined ? 'mousewheel' : 'DOMMouseScroll';\n          }\n\n          return wheelType;\n        }; // runs callback functions\n\n\n        var fireFunctions = function fireFunctions(type) {\n          for (var i = 0, len = functionList.length; i < len; i++) {\n            if (functionList[i].type === type) {\n              functionList[i].fn.call(undefined, type === 'input' ? currentInput : currentIntent);\n            }\n          }\n        }; // finds matching element in an object\n\n\n        var objPos = function objPos(match) {\n          for (var i = 0, len = functionList.length; i < len; i++) {\n            if (functionList[i].fn === match) {\n              return i;\n            }\n          }\n        };\n\n        var detectScrolling = function detectScrolling(event) {\n          if (mousePos.x !== event.screenX || mousePos.y !== event.screenY) {\n            isScrolling = false;\n            mousePos.x = event.screenX;\n            mousePos.y = event.screenY;\n          } else {\n            isScrolling = true;\n          }\n        }; // manual version of `closest()`\n\n\n        var checkClosest = function checkClosest(elem, tag) {\n          var ElementPrototype = window.Element.prototype;\n\n          if (!ElementPrototype.matches) {\n            ElementPrototype.matches = ElementPrototype.msMatchesSelector || ElementPrototype.webkitMatchesSelector;\n          }\n\n          if (!ElementPrototype.closest) {\n            do {\n              if (elem.matches(tag)) {\n                return elem;\n              }\n\n              elem = elem.parentElement || elem.parentNode;\n            } while (elem !== null && elem.nodeType === 1);\n\n            return null;\n          } else {\n            return elem.closest(tag);\n          }\n        };\n        /*\n         * init\n         */\n        // don't start script unless browser cuts the mustard\n        // (also passes if polyfills are used)\n\n\n        if ('addEventListener' in window && Array.prototype.indexOf) {\n          setUp();\n        }\n        /*\n         * api\n         */\n\n\n        return {\n          // returns string: the current input type\n          // opt: 'intent'|'input'\n          // 'input' (default): returns the same value as the `data-whatinput` attribute\n          // 'intent': includes `data-whatintent` value if it's different than `data-whatinput`\n          ask: function ask(opt) {\n            return opt === 'intent' ? currentIntent : currentInput;\n          },\n          // returns string: the currently focused element or null\n          element: function element() {\n            return currentElement;\n          },\n          // overwrites ignored keys with provided array\n          ignoreKeys: function ignoreKeys(arr) {\n            ignoreMap = arr;\n          },\n          // overwrites specific char keys to update on\n          specificKeys: function specificKeys(arr) {\n            specificMap = arr;\n          },\n          // attach functions to input and intent \"events\"\n          // funct: function to fire on change\n          // eventType: 'input'|'intent'\n          registerOnChange: function registerOnChange(fn, eventType) {\n            functionList.push({\n              fn: fn,\n              type: eventType || 'input'\n            });\n          },\n          unRegisterOnChange: function unRegisterOnChange(fn) {\n            var position = objPos(fn);\n\n            if (position || position === 0) {\n              functionList.splice(position, 1);\n            }\n          },\n          clearStorage: function clearStorage() {\n            window.sessionStorage.clear();\n          }\n        };\n      }();\n      /***/\n\n    }\n    /******/\n    ])\n  );\n});\n\n;\n\n//# sourceURL=webpack:///./node_modules/what-input/dist/what-input.js?")}});